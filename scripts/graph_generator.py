import copy
import random
import numpy as np

class GraphGenerator:
    def __init__(self, mutation_rate=0.3, item_mutation_prob=0.5, correlation_boost=0.7):
        self.mutation_rate = mutation_rate
        self.item_mutation_prob = item_mutation_prob
        self.correlation_boost = correlation_boost
    
    def generate_variant(self, original_graph):
        """Crea una variante mutada del grafo original con protecciones"""
        new_graph = copy.deepcopy(original_graph)
        
        # 1. Mutación de parámetros (segura)
        self._mutate_parameters(new_graph)
        
        # 2. Mutación topológica inteligente
        self._mutate_topology_intelligently(new_graph)
        
        # 3. Mutación de relaciones entre constructos
        self._mutate_construct_relations(new_graph)
        
        return new_graph
    
    def _mutate_parameters(self, graph):
        """Modifica propiedades de los nodos con restricciones psicométricas"""
        for node_id, node in graph.nodes.items():
            if node.type == "item" and random.random() < self.mutation_rate:
                # Mutar parámetros IRT de manera controlada
                self._mutate_irt_parameters(node)
    
    def _mutate_irt_parameters(self, node):
        """Mutación inteligente de parámetros IRT"""
        params = node.properties["irt_parameters"]
        
        # Dificultad: cambios pequeños (±0.2) dentro de [-3, 3]
        if "difficulty" in params:
            new_diff = params["difficulty"] + random.gauss(0, 0.2)
            params["difficulty"] = max(-3.0, min(3.0, new_diff))
        
        # Discriminación: cambios pequeños (±0.3) dentro de [0.3, 3.0]
        if "discrimination" in params:
            new_disc = params["discrimination"] + random.gauss(0, 0.3)
            params["discrimination"] = max(0.3, min(3.0, new_disc))
    
    def _mutate_topology_intelligently(self, graph):
        """Modifica la estructura con protecciones para relaciones críticas"""
        # A. Posible adición de nuevas relaciones (favoreciendo 'correlates_with')
        if random.random() < self.mutation_rate:
            all_nodes = list(graph.nodes.keys())
            if len(all_nodes) >= 2:
                node1, node2 = random.sample(all_nodes, 2)
                
                # Evitar auto-relaciones
                if node1 == node2:
                    return
                
                # Determinar tipo de relación basado en tipos de nodos
                node1_type = graph.get_node(node1).type
                node2_type = graph.get_node(node2).type
                
                # Preferir correlaciones entre constructos
                if node1_type == "construct" and node2_type == "construct":
                    relationship = "correlates_with"
                    properties = {
                        "strength": random.uniform(0.1, 0.8),
                        "correlation": random.uniform(0.1, 0.8),
                        "empirical_support": "Generated by AI"
                    }
                else:
                    # Para otros casos, usar relaciones genéricas
                    relationship = random.choice(["influences", "related_to"])
                    properties = {"strength": random.uniform(0.1, 1.0)}
                
                # Añadir solo si la relación no existe
                if (node1, node2) not in graph.edges:
                    graph.add_edge(node1, node2, relationship, **properties)
        
        # B. Eliminación de relaciones (PROTEGIENDO RELACIONES CRÍTICAS)
        if random.random() < self.mutation_rate and graph.edges:
            # Crear lista de relaciones que se pueden eliminar (excluyendo 'measures')
            removable_edges = [
                edge_key for edge_key, edge in graph.edges.items()
                if edge.type != "measures"  # Proteger relaciones de medida
            ]
            
            if removable_edges:
                edge_to_remove = random.choice(removable_edges)
                del graph.edges[edge_to_remove]
                graph.graph.remove_edge(*edge_to_remove)
    
    def _mutate_construct_relations(self, graph):
        """Refuerza o debilita relaciones entre constructos existentes"""
        # Identificar correlaciones existentes
        correlations = [
            (edge_key, edge) for edge_key, edge in graph.edges.items()
            if edge.type == "correlates_with"
        ]
        
        for (source, target), edge in correlations:
            if random.random() < self.correlation_boost:
                # Reforzar correlación existente
                factor = 1.2 if edge.properties["correlation"] > 0 else 0.8
                new_corr = min(0.95, max(0.05, edge.properties["correlation"] * factor))
                edge.properties["correlation"] = new_corr
            elif random.random() < 0.3:
                # Debilitar correlación existente
                factor = 0.8 if edge.properties["correlation"] > 0 else 1.2
                new_corr = min(0.95, max(0.05, edge.properties["correlation"] * factor))
                edge.properties["correlation"] = new_corr
    
    def _add_new_item(self, graph):
        """Añade un nuevo ítem a un constructo existente (mutación avanzada)"""
        if random.random() < 0.2:  # Probabilidad baja de añadir nuevo ítem
            # Seleccionar un constructo al azar
            constructs = [n for n, node in graph.nodes.items() if node.type == "construct"]
            if not constructs:
                return
            
            target_construct = random.choice(constructs)
            new_item_id = f"new_item_{random.randint(1000,9999)}"
            
            # Crear nuevo ítem con parámetros razonables
            graph.add_node(
                new_item_id,
                "item",
                content=f"Nuevo ítem para {target_construct}",
                irt_parameters={
                    "difficulty": random.uniform(-1.0, 1.0),
                    "discrimination": random.uniform(0.8, 1.8),
                    "guessing": 0.0
                }
            )
            
            # Conectar al constructo
            graph.add_edge(
                new_item_id,
                target_construct,
                "measures",
                strength=random.uniform(0.8, 1.5)
            )
            
            # Conectar a método existente
            methods = [n for n, node in graph.nodes.items() if node.type == "method"]
            if methods:
                graph.add_edge(new_item_id, methods[0], "uses_method")